
#include <iostream>
#include <memory>
#include <chrono>

#include <rogue/utilities/fileio/StreamWriter.h>
#include <rogue/utilities/fileio/StreamWriterChannel.h>
#include <rogue/interfaces/stream/Master.h>
#include <rogue/interfaces/stream/TcpClient.h>
#include <rogue/interfaces/stream/Frame.h>
#include <rogue/interfaces/stream/FrameIterator.h>
#include <rogue/interfaces/stream/FrameLock.h>

#include <eudaq/Producer.hh>

#include "pflib/PolarfireTarget.h"
#include "pflib/rogue/RogueWishboneInterface.h"

/**
 * Interface to a single polarfire 
 */
class PolarfireProducer : public eudaq::Producer, public rogue::interfaces::stream::Master {
 public:
  PolarfireProducer(const std::string & name, const std::string & runcontrol);
  void DoInitialise() override;
  void DoConfigure() override;
  void DoStartRun() override;
  void DoStopRun() override;
  void DoTerminate() override;
  void DoReset() override;
  /// put onto its own tread by eudaq::CommandReceiver
  void RunLoop() override;
  
  static const uint32_t factory_id_ = eudaq::cstr2hash("PolarfireProducer");
 private:
  /// pass end-of-run to separate thread
  bool exiting_run_;
  /// milliseconds the polarfire is busy
  std::chrono::milliseconds pf_busy_ms_;
 private:
  /// connection to polarfire
  std::unique_ptr<pflib::PolarfireTarget> pft_;
  /// how daq event reading is triggered
  enum class L1A_MODE {
    PEDESTAL,
    CHARGE,
    EXTERNAL
  } the_l1a_mode_;
  /// has DMA readout been enabled?
  bool dma_enabled_;
  /// host that we should be watching
  std::string host_;
  /// port of **wishbone** server on that host (DMA server is assumed to be +2)
  int port_;
  /// ID for fpga connected to this polarfire
  int fpga_id_;
  /// output file path
  std::string output_path_;
  /// file prefix (suffix is number generated by file writer)
  std::string file_prefix_{"ldmx_hcal"};
  /// amount of bytes to buffer in memory
  int file_buffer_size_;
};

/**
 * This code registers our class with the central eudaq factory
 * so that it can be constructed when needed
 */
namespace {
auto d = eudaq::Factory<eudaq::Producer>::Register<
    PolarfireProducer, const std::string&, const std::string&>(
    PolarfireProducer::factory_id_);
}

PolarfireProducer::PolarfireProducer(const std::string & name, const std::string & runcontrol)
  : eudaq::Producer(name, runcontrol),
    rogue::interfaces::stream::Master() {}

/**
 * Initialization procedures
 *
 * We open the connection to the wishbone interface and pass
 * this interface connection to our Hcal object which holds 
 * more of the "high-level" functions. We also open the connection
 * to the backend. With Rogue, the wishbone interface and
 * the backend are the same.
 *
 * This is where we decide what type of readout mode will be done
 *  - DMA/stream (not implemented or tested yet)
 *  - MemMap (currently only one supported)
 */
void PolarfireProducer::DoInitialise() try {
  auto ini = GetInitConfiguration();

  host_ = ini->Get("TCP_ADDR", "127.0.0.1");
  port_ = ini->Get("TCP_PORT", 8000);
  EUDAQ_INFO("TCP client listening on " + host_ + ":" + std::to_string(port_));

  // how much data to buffer before writing
  file_buffer_size_ = ini->Get("FILE_BUFF_SIZE",10000);
} catch (const pflib::Exception& e) {
  EUDAQ_THROW("PFLIB ["+e.name()+"] : "+e.message());
}

/**
 * Configuration of connection to polarfire
 *
 * Cases to Handle:
 *  - instance of this class for each polarfire in real world
 *  - specify which polarfire we are
 *  - specify which ROCs are actually there
 *  - every ROC has its own config file
 *  - beam runs, charge injection runs, ...
 *  - e.g. set charge injection amplitude from here
 *  - (pflib) get links up and running properly
 *  - stream vs memory map readout mode from rogue POV
 */
void PolarfireProducer::DoConfigure() try {
  auto conf = GetConfiguration();

  // expected number of milliseconds the PF is busy
  int pf_ro_rate{conf->Get("PF_READOUT_RATE", 100)};
  pf_busy_ms_ = std::chrono::milliseconds(1000/pf_ro_rate);

  // output file writing configuration
  output_path_ = conf->Get("OUTPUT_PATH",".");
  file_prefix_ = conf->Get("FILE_PREFIX","ldmx_hcal");

  // or in independent config file?
  fpga_id_ = conf->Get("FPGA_ID", 0);
  int samples_per_event = conf->Get("SAMPLES_PER_EVENT", 5);

  auto l1a_mode{conf->Get("L1A_MODE","PEDESTAL")};
  EUDAQ_INFO("L1A Trigger Mode set to " + l1a_mode);
  if (l1a_mode == "PEDESTAL") {
    the_l1a_mode_ = L1A_MODE::PEDESTAL;
  } else if (l1a_mode == "CHARGE") {
    the_l1a_mode_ = L1A_MODE::CHARGE;
  } else if (l1a_mode == "EXTERNAL") {
    the_l1a_mode_ = L1A_MODE::EXTERNAL;
  } else {
    EUDAQ_THROW("Unrecognized L1A mode "+l1a_mode);
  }

  auto& daq = pft_->hcal.daq();
  auto& elinks = pft_->hcal.elinks();

  /****************************************************************************
   * ELINKS menu in pftool
   *    RELINK
   *    or manual DELAY and BITSLIP values
   ***************************************************************************/
  if (conf->Get("ELINKS_DO_RELINK",true)) {
    pft_->elink_relink(2);
  } else {
    for (int i{0}; i < elinks.nlinks(); i++) {
      elinks.setBitslipAuto(i,false);
      elinks.setBitslip(i,
          conf->Get("ELINK_"+std::to_string(i)+"_BITSLIP", elinks.getBitslip(i)));
      elinks.setDelay(i,
          conf->Get("ELINK_"+std::to_string(i)+"_DELAY", 128));
    }
  }

  /****************************************************************************
   * DAQ.SETUP menu in pftool commands
   *    FPGA
   *    DMA
   *    STANDARD 
   *    L1APARAMS
   *    MULTISAMPLE
   ***************************************************************************/
  daq.setIds(fpga_id_);

  dma_enabled_ = conf->Get("DO_DMA_RO",true);
  if (dma_enabled_) {
    auto rwbi = dynamic_cast<pflib::rogue::RogueWishboneInterface*>(pft_->wb);
    rwbi->daq_dma_enable(true);
    rwbi->daq_dma_setup((uint8_t)fpga_id_, (uint8_t)samples_per_event);
  }

  for (int i{0}; i < elinks.nlinks(); i++) {
    bool active{conf->Get("LINK_"+std::to_string(i)+"_ACTIVE",false)};
    elinks.markActive(i,active);
    if (elinks.isActive(i)) {
      daq.setupLink(i,false,false,15,40);
      int delay{conf->Get("LINK_"+std::to_string(i)+"_L1A_DELAY", 15)};
      int capture{conf->Get("LINK_"+std::to_string(i)+"_L1A_LENGTH", 40)};
      uint32_t reg = ((delay&0xff)<<8)|((capture&0xff)<<16);
      pft_->wb->wb_write(pflib::tgt_DAQ_Inbuffer,(i << 7)|1, reg);
    } else {
      // fully zero suppress this link
      daq.setupLink(i,true,true,15,40);
    }
  }

  /****************************************************************************
   * ROC menu in pftool
   *    HARDRESET
   *    RESYNCLOAD
   *    LOAD_PARAM
   ***************************************************************************/
  pft_->hcal.hardResetROCs(); // global reset
  pft_->hcal.resyncLoadROC(); // loops over ROCs if no i_roc provided
  for (int i{0}; i < 4; i++) {
    if (elinks.isActive(2*i) or elinks.isActive(2*i+1)) {
      // either or both of the links on this ROC are active
      pft_->loadROCParameters(i,
          conf->Get("ROC_"+std::to_string(i)+"_CONF_FILE_PATH",""),
          conf->Get("ROC_"+std::to_string(i)+"_PREPEND_DEFAULTS",true));
    }
  }
} catch (const pflib::Exception& e) {
  EUDAQ_THROW("PFLIB ["+e.name()+"] : "+e.message());
}

/**
 * Start of run, softer reset to start cleanly
 *  - Jeremy's branch
 *  - flags for "external" or various "local" modes
 */
void PolarfireProducer::DoStartRun()  try {
  exiting_run_ = false;
  pft_->prepareNewRun();
  if (the_l1a_mode_ == L1A_MODE::EXTERNAL)
    pft_->backend->fc_enables(true,true,false);
} catch (const pflib::Exception& e) {
  EUDAQ_THROW("PFLIB ["+e.name()+"] : "+e.message());
}

/**
 * Clean close
 */
void PolarfireProducer::DoStopRun(){
  exiting_run_ = true;
  if (the_l1a_mode_ == L1A_MODE::EXTERNAL)
    pft_->backend->fc_enables(false,true,false);
}
/**
 * i.e. recover from failure, this is the only available
 * command if the producer ends up in an error state
 *
 * Go back to "newly created" essentially
 */
void PolarfireProducer::DoReset(){
  exiting_run_ = true;
  // LOCK_UN lock file?
  pf_busy_ms_ = std::chrono::milliseconds();
}
/**
 * Not sure what this does...
 */
void PolarfireProducer::DoTerminate(){
  exiting_run_ = true;
  // close lock file?
}

class DMAReceiver : public rogue::interfaces::stream::Slave {
  std::queue<std::vector<uint8_t>> event_buffer_;
 public:
  static std::shared_ptr<DMAReceiver> create() {
    static std::shared_ptr<DMAReceiver> ret =
      std::make_shared<DMAReceiver>();
    return(ret);
  }
  DMAReceiver() : rogue::interfaces::stream::Slave() { }
  /// get next event from event buffer
  const std::vector<uint8_t>& next() {
    return event_buffer_.front();
  }
  /// pop next event from event buffer
  void pop() {
    event_buffer_.pop();
  }
  void acceptFrame (std::shared_ptr<rogue::interfaces::stream::Frame> frame) {
    auto lock = frame->lock();
    event_buffer_.emplace(frame->begin(),frame->end());
  }
};

/**
 * Include some "mode" about if sending our own L1A ("local" mode)
 * or some "external" mode where L1A is generated elsewhere
 *
 * This function is put onto its own thread by eudaq::CommandReceiver
 * when the run is started. This allows us to receive run control
 * commands without interfering with waiting for the polarfire to
 * respond to our wishbone commands.
 *
 * After setting up the writer to stream this data directly to disk,
 * we enter a loop which only exits when DoStopRun is called to modify
 * the member variable.
 */
void PolarfireProducer::RunLoop() try {
  auto pf_start_run = std::chrono::steady_clock::now();
  std::time_t tt = time(NULL);
  std::tm gmtm = *std::gmtime(&tt); //GMT (UTC)
  std::shared_ptr<rogue::interfaces::stream::TcpClient> tcp;
  std::shared_ptr<DMAReceiver> dma_data_src;
  /// run has begun, open writer for this polarfire
  rogue::utilities::fileio::StreamWriterPtr writer{
    rogue::utilities::fileio::StreamWriter::create()};
  writer->setBufferSize(file_buffer_size_);
  std::stringstream output_file;
  output_file << output_path_ << "/" 
    << file_prefix_ 
    << "_run_" << GetRunNumber() 
    << "_" << gmtm.tm_year << "Y" << gmtm.tm_mon << "m" << gmtm.tm_mday << "d"
    << "_" << gmtm.tm_hour << "H" << gmtm.tm_min << "M" << gmtm.tm_sec << "S"
    << ".raw";
  EUDAQ_INFO("Writing data stream to "+output_file.str());
  try {
    writer->open(output_file.str());
    if (dma_enabled_) {
      // set event tag for firmware
      pft_->backend->daq_setup_event_tag(GetRunNumber(), 
          gmtm.tm_mday, gmtm.tm_mon+1, gmtm.tm_hour, gmtm.tm_min);
      // connect rogue streams
      EUDAQ_INFO("Receiving DMA data from "+host_+":"+std::to_string(port_+2));
      tcp = rogue::interfaces::stream::TcpClient::create(host_,port_+2);
      dma_data_src = DMAReceiver::create();
      tcp->addSlave(writer->getChannel(0));
      tcp->addSlave(dma_data_src);
    } else {
      this->addSlave(writer->getChannel(0));
    }
  } catch (const std::exception& e) {
    EUDAQ_THROW("Rogue Error : "+std::string(e.what()));
  }

  /// loop until we receive end-of-run
  auto pf_trigger = std::chrono::steady_clock::now();
  auto pf_end_of_busy = pf_trigger + pf_busy_ms_;
  while (not exiting_run_) {
    // depending on configured mode, we trigger daq readout or not
    switch(the_l1a_mode_) {
      case L1A_MODE::PEDESTAL:
        pft_->backend->fc_sendL1A();
        break;
      case L1A_MODE::CHARGE:
        pft_->backend->fc_calibpulse();
        break;
      default:
        // external - l1a triggered elsewhere
        break;
    }

    // wait current daq window is done
    std::this_thread::sleep_until(pf_end_of_busy);
    // start next window timer
    pf_trigger = std::chrono::steady_clock::now();
    pf_end_of_busy = pf_trigger + pf_busy_ms_;

    // get event data and push it along the pipeline
    std::vector<uint8_t> event_data;
    if (dma_enabled_) {
      // DMA pushes data to TCP server which pushes it along to writer
      // need to pop last event packet from TCP server using our DMAReceiver
      event_data = dma_data_src->next();
      dma_data_src->pop();
      // no sendFrame necessary since the TCP bridge is connected directly
      // to the file writer
    } else {
      // without DMA enabled, need to PULL data from polarfire
      std::vector<uint32_t> event_data_words = pft_->daqReadEvent();
    
      // cut data words into bytes
      const uint8_t *ptr = reinterpret_cast<const uint8_t*>(&event_data_words[0]);
      std::copy(ptr, ptr + sizeof(uint32_t)*event_data_words.size(), event_data.begin());
    
      // wrap event data in rogue frame to send it to file writer
      auto size = event_data.size();
      auto frame = reqFrame(size, true);
      frame->setPayload(size);
      std::copy(event_data.begin(), event_data.end(), frame->begin());
      sendFrame(frame);
    }
  
    // wrap data in eudaq object and send it downstream to the monitoring
    auto ev = eudaq::Event::MakeUnique("HgcrocRaw");
    ev->AddBlock(fpga_id_, event_data);
    std::chrono::nanoseconds ev_beg(pf_trigger - pf_start_run);
    std::chrono::nanoseconds ev_end(pf_end_of_busy - pf_start_run);
    ev->SetTimestamp(ev_beg.count(), ev_end.count());

    SendEvent(std::move(ev));
  }

  // done writing
  writer->close();
  if (dma_enabled_) {
    dma_data_src->stop();
    tcp->stop();
  }
} catch (const pflib::Exception& e) {
  EUDAQ_THROW("PFLIB ["+e.name()+"] : "+e.message());
}

